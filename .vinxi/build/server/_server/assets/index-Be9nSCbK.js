import*as v from"node:fs";import{s as p,i as y}from"./server-BFLOF_BE.js";import{warning as _,isRedirect as g,isNotFound as m}from"@tanstack/react-router";import"node:async_hooks";import"h3";function x(e){return e instanceof Headers?new Headers(e):Array.isArray(e)?new Headers(e):typeof e=="object"?new Headers(e):new Headers}function F(...e){return e.reduce((t,r)=>{const n=x(r);for(const[a,s]of n.entries())t.set(a,s);return t},new Headers)}const S=[];function l(e,t){const r=t||e||{};return typeof r.method>"u"&&(r.method="GET"),{options:r,middleware:n=>l(void 0,Object.assign(r,{middleware:n})),validator:n=>l(void 0,Object.assign(r,{validator:n})),handler:(...n)=>{const[a,s]=n;Object.assign(r,{...a,extractedFn:a,serverFn:s}),a.url||(console.warn(a),_(!1,"createServerFn must be called with a function that has a 'url' property. Ensure that the @tanstack/start-plugin is ordered **before** the @tanstack/server-functions-plugin."));const i=[...r.middleware||[],E(r)];return Object.assign(async o=>h(i,"client",{...a,method:r.method,data:o?.data,headers:o?.headers,context:{}}).then(d=>{if(d.error)throw d.error;return d.result}),{...a,__executeServer:async o=>{const d=o instanceof FormData?O(o):o;return await h(i,"server",{...a,...d}).then(c=>({result:c.result,error:c.error,context:c.sendContext}))}})}}}function O(e){const t=e.get("__TSR_CONTEXT");if(e.delete("__TSR_CONTEXT"),typeof t!="string")return{context:{},data:e};try{return{context:p.parse(t),data:e}}catch{return{data:e}}}function b(e){const t=new Set,r=[],n=a=>{a.forEach(s=>{s.options.middleware&&n(s.options.middleware),t.has(s)||(t.add(s),r.push(s))})};return n(e),r}const f=async(e,t,r)=>e({...t,next:async(n={})=>r({...t,...n,context:{...t.context,...n.context},sendContext:{...t.sendContext,...n.sendContext??{}},headers:F(t.headers,n.headers),result:n.result!==void 0?n.result:t.result,error:n.error??t.error})});function C(e,t){if(e==null)return{};if("~standard"in e){const r=e["~standard"].validate(t);if(r instanceof Promise)throw new Error("Async validation not supported");if(r.issues)throw new Error(JSON.stringify(r.issues,void 0,2));return r.value}if("parse"in e)return e.parse(t);if(typeof e=="function")return e(t);throw new Error("Invalid validator type!")}async function h(e,t,r){const n=b([...S,...e]),a=async s=>{const i=n.shift();if(!i)return s;i.options.validator&&(t!=="client"||i.options.validateClient)&&(s.data=await C(i.options.validator,s.data));const o=t==="client"?i.options.client:i.options.server;return o?f(o,s,async d=>{const u=i.options.clientAfter;if(t==="client"&&u){const c=await a(d);return f(u,{...d,...c},w=>w)}return a(d).catch(c=>{if(g(c)||m(c))return{...d,error:c};throw c})}):a(s)};return a({...r,headers:r.headers||{},sendContext:r.sendContext||{},context:r.context||{}})}function E(e){return{_types:void 0,options:{validator:e.validator,validateClient:e.validateClient,client:async({next:t,sendContext:r,...n})=>{var a;const s=await((a=e.extractedFn)==null?void 0:a.call(e,{...n,context:r}));return t(s)},server:async({next:t,...r})=>{var n;const a=await((n=e.serverFn)==null?void 0:n.call(e,r));return t({...r,result:a})}}}}function T(e){return e.replace(/^\/|\/$/g,"")}const H=(e,t,r)=>{y(r);const n=`/${T(t)}/${e}`;return Object.assign(r,{url:n,functionId:e})},M="count.txt";async function j(){return parseInt(await v.promises.readFile(M,"utf-8").catch(()=>"0"))}const A=H("app_routes_index_tsx--getCount_createServerFn_handler","/_server",e=>N.__executeServer(e)),N=l({method:"GET"}).handler(A,()=>j());export{A as getCount_createServerFn_handler};
